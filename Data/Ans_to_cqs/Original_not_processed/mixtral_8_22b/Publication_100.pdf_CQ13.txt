Use the following pieces of context to answer the question at the end. If you don't know the answer, just say that you don't know, don't try to make up an answer.

4.5. Implementation details

We have implemented our models in PyTorch (Paszke et al., 2017).
We trained ğ‘€ = 5 models with batch size ğµ = 64 and a base learning
rate ğ›¼ = 10âˆ’4. The learning rate is automatically reduced by a factor
of 0.1 when the validation loss has not improved for 15 consecutive
epochs. We apply weight decay to control the strength of the unit
Gaussian prior, with an empirically chosen magnitude of 10âˆ’3 that
is inversely proportional to the hyperparameter ğœ† from Eq. (1). We
chose ğ›½1 = 0.9, ğ›½2 = 0.999 and ğœ– = 10âˆ’8 as hyper-parameters for the
Adam optimizer. Each neural network was trained on a single Nvidia
RTX2080Ti GPU for âˆ¼14 days.

5. Experimental results and discussion

4.3. Loss function

The loss function, which is optimized during training, measures
the quality of a set of network parameters ğœ½ w.r.t. the training data
îˆ° = {(ğ’™ğ‘–, ğ’šğ‘–)}ğ‘
ğ‘–=1, under some regularizing prior assumptions. We use a
standard loss function îˆ¸(îˆ°; ğœ½) whose minimization corresponds to max-
imizing the posterior probability of the parameters given the training
data. As it is commonly done in machine learning (see e.g. Goodfellow
et al., 2016), we assume a zero-mean isotropic Gaussian prior over
the network parameters (corresponding to îˆ¸
2 regularization) and a
Gaussian likelihood function with mean Ì‚ğğ‘– âˆ¶= Ì‚ğ(ğ’™ğ‘–; ğœ½) âˆˆ R5 and
diagonal covariance matrix with logarithmic elements Ì‚ğ’”ğ‘– âˆ¶= Ì‚ğ’”(ğ’™ğ‘–; ğœ½) âˆˆ
R5:

îˆ¸(îˆ°; ğœ½) = ğœ† â€–ğœ½â€–

2
2 +

âˆ‘

[ Ì‚ğ‘ ğ‘–ğ‘— + exp(âˆ’ Ì‚ğ‘ ğ‘–ğ‘— )( Ì‚ğœ‡ğ‘–ğ‘— âˆ’ ğ‘¦ğ‘–ğ‘— )2]

ğ‘–,ğ‘—

(1)

As commonly done in deep learning, we iteratively learn the model
parameters with stochastic gradient descend, starting from a random
initialization. In each iteration, we randomly sample a batch of ğµ = 64
reference data patches of size 15 Ã— 15 pixels, where a patch is only
considered for training if the center pixel is forested. We consider a
pixel forested if and only if it contains vegetation points (points with
ğ·ğ‘§ > 1.3 m, see Section 3.1) and also is considered forested based on
NIBIOâ€™s Norway-wide timber volume map (Astrup et al., 2019). We use
the latter as an additional precautionary measure to avoid unnecessary
noise from non-forested areas, as we are interested in learning forest
characteristics only. For every reference data patch, we randomly pick
an optical image from the correct year and two SAR images (one as-
cending and one descending orbit) with acquisition dates near the one
of the optical image. Using SAR with both ascending and descending

the Adam (Kingma and Ba, 2015) variant of stochastic gradient descent
(SGD), which adaptively scales the magnitude of the parameter updates
based on the statistics of previous updates to speed up convergence.
During training, we periodically evaluate the prediction error of the
model (i.e., the current set of parameters) on a held-out validation set
and keep the configuration ğœ½âˆ— with the lowest error as the final model.

Question: %INSTRUCTIONS:
Use the provided pieces of context to answer the query in less than 400 words. If you don't know the answer, just say that you don't know, don't try to make up an answer.

%Query
Query: "What are the hyperparameters used in the deep learning model (e.g., learning rate, optimizer)?"

Provide your answer as follows:

Answer:::
Answer: (provide your answer to query in less than 400 words)

Answer:::

Helpful Answer:
The deep learning model uses the Adam optimizer with hyperparameters ğ›½1 = 0.9, ğ›½2 = 0.999, and ğœ– = 10^-8. The initial base learning rate is set to ğ›¼ = 10^-4, which is then automatically reduced by a factor of 0.1 when the validation loss does not improve for 15 consecutive epochs. Weight decay is applied to control the strength of the unit Gaussian prior, with a magnitude of 10^-3 that is inversely proportional to the hyperparameter ğœ† from Equation (1). The model is trained using stochastic gradient descent with a batch size of ğµ = 64.